
import useResizeObserver from "use-resize-observer";
import { Main } from "./components/Main";
import { type PhotosChunk } from "./photosChunk";
import {
  QueryClient,
  QueryClientProvider
} from 'react-query';

import cl from './common.module.scss';

// TODO: Нужно сделать чтобы при наведении мышки - фотка на которую навелись рисовалась как бы приподнятой над остальными (выходит на передний план, с плавной анимацией)
// (кст. при открытии попапа с фуллскрин фоткой тоже можно какую то анимацию замутить транслейта из мелкой фотки в большую. И в большом просмотрщике, пока грузится большая фотка, можно показывать маленькую)
// - так вот она когда приподнимается - она рисуется всегда необрезанной, даже если мой лейаут ее обрезал. Но т.к. она приподнимается над остальными - то ее видно.
// мышка при этом при наведении должна игнорировать приподнятую фотку а наводиться именно на бэкграунд, чтобы не было такого что при наведении на фотку которую перекрыла эта поднявшаяся нужно было
// обходить мышкой эту поднятую фотку чтобы выбрать другую.
//
// Также должна быть возможность на фотках ставить "лайки" (не в вк а локально в своей проге) чтобы они вперед выносились в списке при следующем просмотре фоток.
// так что думаю тут нужно вообще вынести наружу из этого компонента рендер-код для отдельной картинки. Через children возможно сделать


// TODO: нужно подвязать размерности (width) на систему брейкпоинтов.
// изначально в компонент передавать настройки брейкпоинтов, тогда при построении layout-а,
// будет сразу на все эти брейкпоинты расчитываться разметка галереи и тогда при изменении ширины
// будут аплаится размерности из соответствущего массива с брейкпоинтами.
// То есть на данный момент есть только один массив - layoutRows, а будет их несколько на каждый брейкпоинт возможный.
// Тогда при изменении размерностей не надо будет пересчитывать в этот момент огромный список фоток потенциальный - а просто переключается
// массив используемый с размерностями + делается что то типа "перейти по скроллу к элементу номер такому то" - чтобы сохранить положение фотки внутри скролла.
// можно сохранять оффсет фотки (1ой например) которая находится в видимости вьюпорта и считать % этого оффсета отностиельно высоты вьюпорта. И после изменения брейкпоинта
// переходить на такие же параметры - ту же фотку делать 1ой во вьюпорте и двигать на тот же %.

const queryClient = new QueryClient();

export type InfiniteGalleryProps = {
  getNextPhotosChunk(offset: number, limit: number): Promise<PhotosChunk>;

  minRowHeight?: number;
  maxRowHeight?: number;

  gap?: number;

  paddingLeft?: number;
  paddingRight?: number;
  paddingTop?: number;
  paddingBottom?: number;
};

export function InfiniteGallery(props: InfiniteGalleryProps) {
  const resizeObserver = useResizeObserver<HTMLDivElement>()

  return (
    <div ref={resizeObserver.ref} className={cl.wrapper}>
      <QueryClientProvider client={queryClient}>
        <Main
          width={resizeObserver.width ?? 0}
          maxHeight={resizeObserver.height ?? 0}
          {...props}
        />
      </QueryClientProvider>
    </div>
  );
}
